#!/usr/bin/env node

/**
 * Script de Testing Automatizado para El Almac√©n de los Recuerdos
 * Ejecuta tests de integraci√≥n, funcionalidad y validaci√≥n
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Colores para output
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  reset: '\x1b[0m',
  bold: '\x1b[1m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logSection(title) {
  console.log('\n' + '='.repeat(60));
  log(title, 'bold');
  console.log('='.repeat(60));
}

// Verificar estructura del proyecto
function validateProjectStructure() {
  logSection('üîç VALIDANDO ESTRUCTURA DEL PROYECTO');
  
  const requiredFiles = [
    'package.json',
    'src/App.tsx',
    'src/hooks/useAuth.tsx',
    'src/hooks/useMemories.tsx',
    'src/hooks/useNavigation.tsx',
    'src/services/electronAPI.ts',
    'src/components/ErrorBoundary.tsx',
    'src/components/RouteErrorBoundary.tsx',
    'src/backend/main.js',
    'preload.js'
  ];

  const requiredDirectories = [
    'src/components',
    'src/hooks',
    'src/pages',
    'src/services',
    'src/utils',
    'src/types'
  ];

  let allValid = true;

  // Verificar archivos
  log('\nüìÑ Verificando archivos requeridos:');
  requiredFiles.forEach(file => {
    const exists = fs.existsSync(path.join(__dirname, '..', file));
    if (exists) {
      log(`  ‚úÖ ${file}`, 'green');
    } else {
      log(`  ‚ùå ${file} - FALTANTE`, 'red');
      allValid = false;
    }
  });

  // Verificar directorios
  log('\nüìÅ Verificando directorios:');
  requiredDirectories.forEach(dir => {
    const exists = fs.existsSync(path.join(__dirname, '..', dir));
    if (exists) {
      log(`  ‚úÖ ${dir}/`, 'green');
    } else {
      log(`  ‚ùå ${dir}/ - FALTANTE`, 'red');
      allValid = false;
    }
  });

  return allValid;
}

// Verificar dependencias
function validateDependencies() {
  logSection('üì¶ VALIDANDO DEPENDENCIAS');
  
  try {
    const packageJson = JSON.parse(fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8'));
    
    const requiredDeps = [
      'react',
      'react-dom',
      'react-router-dom',
      'typescript',
      'vite',
      '@types/react',
      'tailwindcss'
    ];

    const allDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };
    
    log('\nüîç Verificando dependencias cr√≠ticas:');
    let allValid = true;
    
    requiredDeps.forEach(dep => {
      if (allDeps[dep]) {
        log(`  ‚úÖ ${dep} - ${allDeps[dep]}`, 'green');
      } else {
        log(`  ‚ùå ${dep} - FALTANTE`, 'red');
        allValid = false;
      }
    });

    // Verificar scripts importantes
    log('\n‚öôÔ∏è Verificando scripts de npm:');
    const requiredScripts = ['dev', 'build', 'electron:dev'];
    
    requiredScripts.forEach(script => {
      if (packageJson.scripts && packageJson.scripts[script]) {
        log(`  ‚úÖ ${script}`, 'green');
      } else {
        log(`  ‚ö†Ô∏è ${script} - FALTANTE`, 'yellow');
      }
    });

    return allValid;
  } catch (error) {
    log(`‚ùå Error leyendo package.json: ${error.message}`, 'red');
    return false;
  }
}

// Verificar configuraci√≥n de TypeScript
function validateTypeScriptConfig() {
  logSection('üìù VALIDANDO CONFIGURACI√ìN TYPESCRIPT');
  
  const tsConfigFiles = ['tsconfig.json', 'tsconfig.app.json', 'tsconfig.node.json'];
  let allValid = true;

  tsConfigFiles.forEach(file => {
    const exists = fs.existsSync(path.join(__dirname, '..', file));
    if (exists) {
      try {
        const config = JSON.parse(fs.readFileSync(path.join(__dirname, '..', file), 'utf8'));
        log(`  ‚úÖ ${file} - V√°lido`, 'green');
      } catch (error) {
        log(`  ‚ùå ${file} - JSON inv√°lido: ${error.message}`, 'red');
        allValid = false;
      }
    } else {
      log(`  ‚ö†Ô∏è ${file} - No encontrado`, 'yellow');
    }
  });

  return allValid;
}

// Test de compilaci√≥n TypeScript
function testTypeScriptCompilation() {
  logSection('üîß TESTING COMPILACI√ìN TYPESCRIPT');
  
  try {
    log('Ejecutando verificaci√≥n de tipos...', 'blue');
    execSync('npx tsc --noEmit', { 
      cwd: path.join(__dirname, '..'),
      stdio: 'pipe'
    });
    log('‚úÖ Compilaci√≥n TypeScript exitosa', 'green');
    return true;
  } catch (error) {
    log('‚ùå Errores de TypeScript encontrados:', 'red');
    console.log(error.stdout?.toString() || error.message);
    return false;
  }
}

// Test de build de producci√≥n
function testProductionBuild() {
  logSection('üèóÔ∏è TESTING BUILD DE PRODUCCI√ìN');
  
  try {
    log('Ejecutando build de producci√≥n...', 'blue');
    const output = execSync('npm run build', { 
      cwd: path.join(__dirname, '..'),
      stdio: 'pipe'
    });
    
    // Verificar que se cre√≥ el directorio dist
    const distExists = fs.existsSync(path.join(__dirname, '..', 'dist'));
    if (distExists) {
      log('‚úÖ Build de producci√≥n exitoso', 'green');
      log('‚úÖ Directorio dist creado correctamente', 'green');
      
      // Verificar archivos principales
      const indexHtml = fs.existsSync(path.join(__dirname, '..', 'dist', 'index.html'));
      if (indexHtml) {
        log('‚úÖ index.html generado', 'green');
      } else {
        log('‚ö†Ô∏è index.html no encontrado en dist', 'yellow');
      }
      
      return true;
    } else {
      log('‚ùå Directorio dist no fue creado', 'red');
      return false;
    }
  } catch (error) {
    log('‚ùå Error en build de producci√≥n:', 'red');
    console.log(error.stdout?.toString() || error.message);
    return false;
  }
}

// Verificar configuraci√≥n de Electron
function validateElectronConfig() {
  logSection('‚ö° VALIDANDO CONFIGURACI√ìN ELECTRON');
  
  const electronFiles = [
    'electron.js',
    'preload.js',
    'src/backend/main.js'
  ];

  let allValid = true;

  electronFiles.forEach(file => {
    const exists = fs.existsSync(path.join(__dirname, '..', file));
    if (exists) {
      log(`  ‚úÖ ${file}`, 'green');
    } else {
      log(`  ‚ùå ${file} - FALTANTE`, 'red');
      allValid = false;
    }
  });

  // Verificar que electron est√© en dependencias
  try {
    const packageJson = JSON.parse(fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8'));
    const allDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };
    
    if (allDeps.electron) {
      log(`  ‚úÖ Electron dependency - ${allDeps.electron}`, 'green');
    } else {
      log('  ‚ö†Ô∏è Electron no est√° en dependencias', 'yellow');
    }
  } catch (error) {
    log('  ‚ùå Error verificando dependencias de Electron', 'red');
    allValid = false;
  }

  return allValid;
}

// Test de funcionalidades cr√≠ticas (an√°lisis est√°tico)
function testCriticalFunctionalities() {
  logSection('üß™ TESTING FUNCIONALIDADES CR√çTICAS');
  
  const tests = [
    {
      name: 'Hook useAuth',
      file: 'src/hooks/useAuth.tsx',
      patterns: ['useContext', 'createContext', 'login', 'logout', 'isAuthenticated']
    },
    {
      name: 'Hook useMemories',
      file: 'src/hooks/useMemories.tsx',
      patterns: ['saveMemory', 'loadMemories', 'selectSaveDirectory', 'saveFileToDirectory']
    },
    {
      name: 'Hook useNavigation',
      file: 'src/hooks/useNavigation.tsx',
      patterns: ['navigate', 'isValidRoute', 'canAccessRoute', 'getCurrentRouteInfo']
    },
    {
      name: 'ElectronService',
      file: 'src/services/electronAPI.ts',
      patterns: ['authenticate', 'saveMemory', 'showSaveDialog', 'isAvailable']
    },
    {
      name: 'ErrorBoundary',
      file: 'src/components/ErrorBoundary.tsx',
      patterns: ['componentDidCatch', 'getDerivedStateFromError', 'resetError']
    }
  ];

  let allValid = true;

  tests.forEach(test => {
    const filePath = path.join(__dirname, '..', test.file);
    
    if (fs.existsSync(filePath)) {
      try {
        const content = fs.readFileSync(filePath, 'utf8');
        const missingPatterns = test.patterns.filter(pattern => !content.includes(pattern));
        
        if (missingPatterns.length === 0) {
          log(`  ‚úÖ ${test.name} - Todas las funciones encontradas`, 'green');
        } else {
          log(`  ‚ö†Ô∏è ${test.name} - Funciones faltantes: ${missingPatterns.join(', ')}`, 'yellow');
          allValid = false;
        }
      } catch (error) {
        log(`  ‚ùå ${test.name} - Error leyendo archivo: ${error.message}`, 'red');
        allValid = false;
      }
    } else {
      log(`  ‚ùå ${test.name} - Archivo no encontrado: ${test.file}`, 'red');
      allValid = false;
    }
  });

  return allValid;
}

// Generar reporte
function generateReport(results) {
  logSection('üìä GENERANDO REPORTE');
  
  const totalTests = Object.keys(results).length;
  const passedTests = Object.values(results).filter(Boolean).length;
  const passRate = (passedTests / totalTests) * 100;

  const reportContent = `# Reporte de Testing Automatizado
## El Almac√©n de los Recuerdos

**Fecha:** ${new Date().toLocaleString()}
**Tests ejecutados:** ${totalTests}
**Tests exitosos:** ${passedTests}
**Tasa de √©xito:** ${passRate.toFixed(2)}%

## Resultados Detallados

${Object.entries(results).map(([test, passed]) => 
  `- ${passed ? '‚úÖ' : '‚ùå'} **${test}**`
).join('\n')}

## Estado General

${passRate >= 90 ? 'üéâ **EXCELENTE** - Sistema listo para producci√≥n' :
  passRate >= 70 ? '‚ö†Ô∏è **ACEPTABLE** - Algunos problemas menores a resolver' :
  '‚ùå **CR√çTICO** - Problemas importantes que requieren atenci√≥n'}

## Pr√≥ximos Pasos

${passRate >= 90 ? 
  '- ‚úÖ Proceder con deployment\n- ‚úÖ Ejecutar tests en entorno de producci√≥n' :
  passRate >= 70 ?
  '- ‚ö†Ô∏è Revisar y corregir problemas menores\n- ‚ö†Ô∏è Re-ejecutar tests despu√©s de correcciones' :
  '- ‚ùå Corregir problemas cr√≠ticos identificados\n- ‚ùå No proceder con deployment hasta resolver todos los problemas'
}

---
*Generado autom√°ticamente por script de testing*
`;

  const reportPath = path.join(__dirname, '..', 'testing-report.md');
  fs.writeFileSync(reportPath, reportContent);
  
  log(`üìÑ Reporte generado: ${reportPath}`, 'cyan');
  
  return { passRate, reportPath };
}

// Funci√≥n principal
function main() {
  log('üöÄ INICIANDO TESTING AUTOMATIZADO - EL ALMAC√âN DE LOS RECUERDOS', 'bold');
  log('================================================================', 'blue');
  
  const results = {};
  
  // Ejecutar todos los tests
  results['Estructura del Proyecto'] = validateProjectStructure();
  results['Dependencias'] = validateDependencies();
  results['Configuraci√≥n TypeScript'] = validateTypeScriptConfig();
  results['Compilaci√≥n TypeScript'] = testTypeScriptCompilation();
  results['Build de Producci√≥n'] = testProductionBuild();
  results['Configuraci√≥n Electron'] = validateElectronConfig();
  results['Funcionalidades Cr√≠ticas'] = testCriticalFunctionalities();

  // Generar reporte
  const { passRate, reportPath } = generateReport(results);

  // Resultado final
  logSection('üéØ RESULTADO FINAL');
  
  if (passRate >= 90) {
    log('üéâ ¬°EXCELENTE! Sistema completamente funcional', 'green');
    log('‚úÖ Listo para deployment en producci√≥n', 'green');
  } else if (passRate >= 70) {
    log('‚ö†Ô∏è Sistema funcional con problemas menores', 'yellow');
    log('‚ö†Ô∏è Revisar y corregir antes del deployment', 'yellow');
  } else {
    log('‚ùå Problemas cr√≠ticos encontrados', 'red');
    log('‚ùå NO proceder con deployment', 'red');
  }

  log(`\nüìä Tasa de √©xito: ${passRate.toFixed(2)}%`, 'cyan');
  log(`üìÑ Reporte completo: ${reportPath}`, 'cyan');

  // Exit code
  process.exit(passRate >= 70 ? 0 : 1);
}

// Ejecutar si es llamado directamente
if (require.main === module) {
  main();
}

module.exports = {
  validateProjectStructure,
  validateDependencies,
  testTypeScriptCompilation,
  testProductionBuild,
  generateReport
};
